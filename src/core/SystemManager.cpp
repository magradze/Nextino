/**
 * @file        SystemManager.cpp
 * @title       System Manager Implementation
 * @description Implements the logic for the `SystemManager` class, including
 *              module registration, resource management, and lifecycle control.
 *
 * @author      Giorgi Magradze
 * @date        2025-08-21
 * @version     0.2.0
 *
 * @copyright   (c) 2025 Nextino. All rights reserved.
 * @license     MIT License
 */

#include "SystemManager.h"
#include "Scheduler.h"
#include "ModuleFactory.h"
#include "Logger.h"
#include "ResourceManager.h" // <-- 1. ვრთავთ ResourceManager-ის ჰედერს
#include <ArduinoJson.h>

// This header is auto-generated by the project's build script
#include "generated_config.h"

SystemManager &SystemManager::getInstance()
{
    static SystemManager *instance = nullptr;
    if (instance == nullptr)
    {
        instance = new SystemManager();
    }
    return *instance;
}

void SystemManager::registerModule(BaseModule *module)
{
    if (module)
    {
        modules.push_back(module);
        NEXTINO_CORE_LOG(LogLevel::Debug, "SysManager", "Module '%s' queued for registration.", module->getName());
    }
}

void SystemManager::begin()
{
    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "System startup sequence initiated.");

    JsonDocument doc;
    DeserializationError error = deserializeJson(doc, projectConfigJson);

    if (error)
    {
        NEXTINO_CORE_LOG(LogLevel::Error, "SysManager", "Failed to parse JSON config: %s. Halting.", error.c_str());
        while (true)
        {
        } // Halt on critical error
    }

    // --- PHASE 1: RESOURCE RESERVATION ---
    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "Phase 1: Locking all declared hardware resources...");
    bool allResourcesLocked = true;
    JsonArray modulesConfig = doc["modules"];

    for (JsonObject moduleConf : modulesConfig)
    {
        const char *moduleType = moduleConf["type"];
        if (!moduleType)
            continue; // Skip if module type is not defined

        JsonObject config = moduleConf["config"];
        if (!config)
            continue;

        if (config.containsKey("resource"))
        {
            JsonObject resourceObj = config["resource"];
            const char *resourceTypeStr = resourceObj["type"];
            if (!resourceTypeStr)
                continue;

            // --- GPIO Resource Handling ---
            if (strcmp(resourceTypeStr, "gpio") == 0)
            {
                if (resourceObj.containsKey("pin"))
                {
                    int pin = resourceObj["pin"];
                    if (!NextinoResources().lock(ResourceType::GPIO, pin, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- I2C Resource Handling ---
            else if (strcmp(resourceTypeStr, "i2c") == 0)
            {
                if (resourceObj.containsKey("address"))
                {
                    // I2C addresses are often hex strings, e.g., "0x76"
                    int address = (int)strtol(resourceObj["address"], NULL, 0);
                    if (!NextinoResources().lock(ResourceType::I2C_ADDRESS, address, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- SPI Resource Handling (by CS Pin) ---
            else if (strcmp(resourceTypeStr, "spi") == 0)
            {
                if (resourceObj.containsKey("cs_pin"))
                {
                    int cs_pin = resourceObj["cs_pin"];
                    if (!NextinoResources().lock(ResourceType::SPI_CS_PIN, cs_pin, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- UART Resource Handling ---
            else if (strcmp(resourceTypeStr, "uart") == 0)
            {
                if (resourceObj.containsKey("port"))
                {
                    int port = resourceObj["port"];
                    if (!NextinoResources().lock(ResourceType::UART_PORT, port, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- ADC Resource Handling ---
            else if (strcmp(resourceTypeStr, "adc") == 0)
            {
                if (resourceObj.containsKey("pin"))
                {
                    int pin = resourceObj["pin"];
                    if (!NextinoResources().lock(ResourceType::ADC_PIN, pin, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- DAC Resource Handling ---
            else if (strcmp(resourceTypeStr, "dac") == 0)
            {
                if (resourceObj.containsKey("pin"))
                {
                    int pin = resourceObj["pin"];
                    if (!NextinoResources().lock(ResourceType::DAC_PIN, pin, moduleType))
                    {
                        allResourcesLocked = false;
                    }
                }
            }
            // --- Unknown Resource Type ---
            else
            {
                NEXTINO_CORE_LOG(LogLevel::Warn, "SysManager", "Module '%s' declared an unknown resource type: '%s'", moduleType, resourceTypeStr);
            }
        }
    }

    if (!allResourcesLocked)
    {
        NEXTINO_CORE_LOG(LogLevel::Error, "SysManager", "RESOURCE CONFLICT DETECTED! Halting system. Please check your configuration.");
        while (true)
        {
        } // Halt on conflict
    }
    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "All resources locked successfully.");

    // --- PHASE 2: MODULE INSTANTIATION ---
    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "Phase 2: Creating and registering module instances...");
    for (JsonObject moduleConf : modulesConfig)
    {
        const char *type = moduleConf["type"];
        JsonObject config = moduleConf["config"];
        BaseModule *module = NextinoFactory().createModule(type, config);
        if (module)
        {
            registerModule(module);
        }
    }

    // --- PHASE 3: MODULE LIFECYCLE EXECUTION ---
    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "Phase 3: Initializing all modules...");
    for (auto *module : modules)
    {
        module->init();
    }

    NEXTINO_CORE_LOG(LogLevel::Info, "SysManager", "Phase 4: Starting all modules...");
    for (auto *module : modules)
    {
        module->start();
    }
}

void SystemManager::loop()
{
    Scheduler::getInstance().loop();
    for (auto *module : modules)
    {
        module->loop();
    }
}